\chapter{Various}

\section{Intervals}
	\kactlimport{IntervalContainer.h}
	\kactlimport{IntervalCover.h}
	\kactlimport{ConstantIntervals.h}

\section{Misc. algorithms}
	\kactlimport{TernarySearch.h}
	\kactlimport{LIS.h}

\section{Dynamic programming}
	\kactlimport{DivideAndConquerDP.h}
  \subsection{Knuth}
  When doing DP on intervals: $a[i][j] = \min_{i < k < j}(a[i][k] + a[k][j]) + f(i, j)$, where the (minimal) optimal $k$ increases with both $i$ and $j$,
  one can solve intervals in increasing order of length, and search $k = p[i][j]$ for $a[i][j]$ only between $p[i][j-1]$ and $p[i+1][j]$.
  This is known as Knuth DP. Sufficient criteria for this are Monotonicity: $f(b,c) \le f(a,d)$ and Quadrangle inequality: $f(a,c) + f(b,d) \le f(a,d) + f(b,c)$ for all $a \le b \le c \le d$.
  Consider also: LineContainer (ch. Data structures), monotone queues, ternary search.
  

\section{Debugging tricks}
	\begin{itemize}
		\item \verb@signal(SIGSEGV, [](int) { _Exit(0); });@ converts segfaults into Wrong Answers.
			Similarly one can catch SIGABRT (assertion failures) and SIGFPE (zero divisions).
			\verb@_GLIBCXX_DEBUG@ failures generate SIGABRT (or SIGSEGV on gcc 5.4.0 apparently).
		\item \verb@feenableexcept(29);@ kills the program on NaNs (\texttt 1), 0-divs (\texttt 4), infinities (\texttt 8) and denormals (\texttt{16}).
	\end{itemize}

\section{Optimization tricks}
	\subsection{Bit hacks}
		\begin{itemize}
			\item \verb@x & -x@ is the least bit in \texttt{x}.
			\item \verb@for (int x = m; x; ) { --x &= m; ... }@ loops over all subset masks of \texttt{m} (except \texttt{m} itself).
			\item \verb@c = x&-x, r = x+c; (((r^x) >> 2)/c) | r@ is the next number after \texttt{x} with the same number of bits set.
			\item \verb@rep(b,0,K) rep(i,0,(1 << K))@ \\ \verb@  if (i & 1 << b) D[i] += D[i^(1 << b)];@ computes all sums of subsets.
		\end{itemize}
	\subsection{Pragmas}
		\begin{itemize}
			\item \lstinline{#pragma GCC optimize ("Ofast")} will make GCC auto-vectorize for loops and optimizes floating points better (assumes associativity and turns off denormals).
			\item \lstinline{#pragma GCC target ("avx,avx2")} can double performance of vectorized code, but causes crashes on old machines.
			\item \lstinline{#pragma GCC optimize ("trapv")} kills the program on integer overflows (but is really slow).
		\end{itemize}
	\kactlimport{FastMod.h}
	\kactlimport{PairHash.h}
	% \kactlimport{FastInput.h}
	\kactlimport{BumpAllocator.h}
	\kactlimport{SmallPtr.h}
	\kactlimport{BumpAllocatorSTL.h}
	\kactlimport{Unrolling.h}
	\kactlimport{SIMD.h}
	\kactlimport{MosAlgo.h}
    \kactlimport{MyScanner.java}
